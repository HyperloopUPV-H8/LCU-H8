#pragma once
#include "LCU_Mode/LCU_Mode.hpp"
#include "Control/Blocks/PID.hpp"
#include "Control/Blocks/Saturator.hpp"
#include "LevitationPositionCalculator.hpp"
#include "Control/Blocks/MovingAverage.hpp"


template<>
class DistanceControl<LCU::MASTER_MODE::LPU_VALIDATION>{
};

template<>
class DistanceControl<LCU::MASTER_MODE::TESTBENCH_1DOF>{
public:
	PID<IntegratorType::Trapezoidal,FilterDerivatorType::Moving_Average,22> pid = {ki,kp,kp,period};
	Saturator<float> target_current_saturator = Saturator((float)0.0,(float)-50.0,(float)50.0);
	static const float reference_distance = 0.0199;
	float target_current = 0.0;
	static const float ki = -7000, kp = -1400, kd = -475, period = 0.001;
	DistanceControl() = default;
	void set_reference_distance(float new_distance){
		reference_distance = new_distance;
	}
	void control(float real_distance){
		pid.input(reference_distance - real_distance/1000.0);
		pid.execute();
		target_current_saturator.input(pid.output_value);
		target_current_saturator.execute();
		target_current = target_current_saturator.output_value;
	}
};

template<>
class DistanceControl<LCU::MASTER_MODE::VEHICLE_5DOF>{
public:
	SimpleDerivator y_derivator, z_derivator, rot_y_derivator, rot_z_derivator, rot_x_derivator;
	Integrator<IntegratorType::Trapezoidal> y_integrator, z_integrator, rot_y_integrator, rot_z_integrator, rot_x_integrator;
	MovingAverage<20> y_filter_derivative, z_filter_derivative, rot_y_filter_derivative, rot_z_filter_derivative, rot_x_filter_derivative;
	LevitationPosition error;
	LevitationPositionCalculator airgap2pos;
	LevitationPosition& levitation_position = airgap2pos.output_value;

	double z_reference = 0.61448;

	static const float period = 0.001;

	double(&current_references[8]);

	DistanceControl(double(&distaces)[8], double(&current_references)[8]) : airgap2pos(distaces), current_references(current_references) {}
private:

	enum U_MATRIX_POSITION{
		POS_Y,
		POS_Z,
		ROT_X,
		ROT_Y,
		ROT_Z,
		dPOS_Y,
		dPOS_Z,
		dROT_X,
		dROT_Y,
		dROT_Z,
		iPOS_Y,
		iPOS_Z,
		iROT_X,
		iROT_Y,
		iROT_Z
	};

	enum Y_MATRIX_POSITION{

	};

	void calculate_error(){
		airgap2pos.execute();
		error = levitation_position;
		error.z = z_reference - levitation_position.z;
	}

public:
	void control(){
		calculate_error();

		//Derivative
		y_derivator.input(error.y);
		z_derivator.input(error.z);
		rot_y_derivator.input(error.rotation_y);
		rot_x_derivator.input(error.rotation_x);
		rot_z_derivator.input(error.rotation_z);
		y_derivator.execute();
		z_derivator.execute();
		rot_y_derivator.execute();
		rot_x_derivator.execute();
		rot_z_derivator.execute();
		y_filter_derivative.input(y_derivator.output_value);
		z_filter_derivative.input(y_derivator.output_value);
		rot_x_filter_derivative.input(y_derivator.output_value);
		rot_y_filter_derivative.input(y_derivator.output_value);
		rot_z_filter_derivative.input(y_derivator.output_value);
		y_filter_derivative.execute();
		z_filter_derivative.execute();
		rot_x_filter_derivative.execute();
		rot_y_filter_derivative.execute();
		rot_z_filter_derivative.execute();

		//Integral
		y_integrator
	}
}
