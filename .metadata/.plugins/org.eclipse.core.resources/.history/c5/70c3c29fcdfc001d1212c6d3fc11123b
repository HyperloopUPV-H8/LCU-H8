///*
// * LCU.hpp
// *
// *  Created on: Apr 6, 2023
// *      Author: stefa
// */
//
//#pragma once
//
//#include "main.h"
//#include "lwip.h"
//#include "ST-LIB.hpp"
//#include "../Src/Runes/Runes.hpp"
//#include "CurrentControl.hpp"
//
//	void take_off();
//
//	void landing();
//
//	void stick_down();
//
//	void stick_up();
//
//	void set_parameters();
//
//	void set_slave_parameters();
//
//	extern float& reference_distance;
//	extern float& target_current;
//	extern float& target_duty;
//
//	extern float current_reference_test;
//	extern float test_duty;
//	extern float bridge_test_duty;
//
//enum LPU_Bridge{
//	HEMS,EMS
//};
//
//enum LPU{
//	LPU_1,
//	LPU_2
//};
//
//extern LPU lpu_selector;
//extern LPU_Bridge lpu_bridge;
//
//struct LCUMasterData{
//	float coil_current_hems_1 = 0;
//	float coil_current_hems_3 = 0;
//	float coil_current_ems_1 = 0;
//	float coil_current_ems_3  = 0;
//
//	float slave_coil_current_hems_2 = 0;
//	float slave_coil_current_hems_4 = 0;
//	float slave_coil_current_ems_2 = 0;
//	float slave_coil_current_ems_4 = 0;
//
//	float coil_temp_1 = 0;
//	float coil_temp_2 = 0;
//	float coil_temp_3 = 0;
//	float coil_temp_4 = 0;
//
//	float slave_coil_temp_1 = 0;
//	float slave_coil_temp_2 = 0;
//	float slave_coil_temp_3 = 0;
//	float slave_coil_temp_4 = 0;
//
//	float lpu_temp_1 = 0;
//	float lpu_temp_2 = 0;
//	float lpu_temp_3 = 0;
//	float lpu_temp_4 = 0;
//
//	float slave_lpu_temp_1 = 0;
//	float slave_lpu_temp_2 = 0;
//	float slave_lpu_temp_3 = 0;
//	float slave_lpu_temp_4 = 0;
//
//	float batt_current_1 = 0;
//	float batt_current_2 = 0;
//
//	float slave_batt_current_1 = 0;
//	float slave_batt_current_2 = 0;
//
//	float batt_voltage_1 = 0;
//	float batt_voltage_2 = 0;
//
//	float slave_batt_voltage_1 = 0;
//	float slave_batt_voltage_2 = 0;
//
//	float airgap_1 = 0;
//	float airgap_3 = 0;
//	float airgap_5 = 0;
//	float airgap_7 = 0;
//
//	float slave_airgap_2 = 0;
//	float slave_airgap_4 = 0;
//	float slave_airgap_6 = 0;
//	float slave_airgap_8 = 0;
//
//	double rotx = 0;
//	double roty = 0;
//	double rotz = 0;
//
//	double reference_current_hems_1 = 0;
//	double reference_current_hems_3 = 0;
//	double reference_current_ems_1 = 0;
//	double reference_current_ems_3 = 0;
//
//	double slave_reference_current_hems_2 = 0;
//	double slave_reference_current_hems_4 = 0;
//	double slave_reference_current_ems_2 = 0;
//	double slave_reference_current_ems_4 = 0;
//
//	float raw_coil_current = 0;
//
//	float* duty = nullptr;
//
//};
//
//LCUMasterData LCU_data;
//
//class LCUActuators{
//public:
//	DigitalOutput buffer_enable;
//
//	DigitalOutput sleep_led;
//	DigitalOutput can_led;
//	DigitalOutput flash_led;
//	DigitalOutput fault_led;
//	DigitalOutput operational_led;
//
//	PWM HEMS_1_H1;
//	PWM HEMS_1_H2;
//
//	PWM HEMS_2_H1;
//	PWM HEMS_2_H2;
//
//	PWM EMS_1_H1;
//	PWM EMS_1_H2;
//
//	PWM EMS_2_H1;
//	PWM EMS_2_H2;
//
//	void inscribe_digital_outputs(){
//		sleep_led = DigitalOutput(PG4);
//		can_led = DigitalOutput(PG6);
//		flash_led = DigitalOutput(PG5);
//		fault_led = DigitalOutput(PG7);
//		operational_led = DigitalOutput(PG8);
//
//		buffer_enable = DigitalOutput(PD14);
//
//		HEMS_1_H1 = PWM(PE9);
//		HEMS_1_H2 = PWM(PE6);
//
//		HEMS_2_H1 = PWM(PE11);
//		HEMS_2_H2 = PWM(PE5);
//
//		EMS_1_H1 = PWM(PE13);
//		EMS_1_H2 = PWM(PE14);
//
//		EMS_2_H1 = PWM(PB4);
//		EMS_2_H2 = PWM(PB5);
//	}
//
//	void toggle_led(){
//		flash_led.toggle();
//	}
//
//	void start(){
//		buffer_enable.turn_off();
//		flash_led.turn_off();
//		can_led.turn_off();
//		operational_led.turn_off();
//		sleep_led.turn_off();
//		fault_led.turn_off();
//		HEMS_1_H1.turn_on();
//		HEMS_1_H2.turn_on();
//		EMS_1_H1.turn_on();
//		EMS_1_H2.turn_on();
//		HEMS_2_H1.turn_on();
//		HEMS_2_H2.turn_on();
//		EMS_2_H1.turn_on();
//		EMS_2_H2.turn_on();
//		HEMS_1_H1.set_frequency(20000);
//		HEMS_1_H2.set_frequency(20000);
//		EMS_1_H1.set_frequency(20000);
//		EMS_1_H2.set_frequency(20000);
//		HEMS_2_H1.set_frequency(20000);
//		HEMS_2_H2.set_frequency(20000);
//		EMS_2_H1.set_frequency(20000);
//		EMS_2_H2.set_frequency(20000);
//		HEMS_1_H1.set_duty_cycle(0);
//		HEMS_1_H2.set_duty_cycle(0);
//		EMS_1_H1.set_duty_cycle(0);
//		EMS_1_H2.set_duty_cycle(0);
//		HEMS_2_H1.set_duty_cycle(0);
//		HEMS_2_H2.set_duty_cycle(0);
//		EMS_2_H1.set_duty_cycle(0);
//		EMS_2_H2.set_duty_cycle(0);
//	}
//};
//
//LCUActuators LCU_actuators;
//
//class LCUSensors{
//public:
//
//	static constexpr float  offset_mecanico = 63.303;
//	static constexpr float max_persistent_current = 40;
//	static constexpr float max_time = 1;
//	static constexpr float frequency = 10000;
//
//	MovingAverage<10> airgap_1_mean;
//	MovingAverage<10> airgap_3_mean;
//	MovingAverage<10> airgap_5_mean;
//	MovingAverage<10> airgap_7_mean;
//	MovingAverage<20> current_hems_1_mean;
//	MovingAverage<20> current_hems_3_mean;
//	MovingAverage<20> current_ems_1_mean;
//	MovingAverage<20> current_ems_3_mean;
//
//	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_hems_1 = {&LCU_data.coil_current_hems_1,max_persistent_current,max_time,frequency};
//	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_hems_3 = {&LCU_data.coil_current_hems_3,max_persistent_current,max_time,frequency};
//	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_ems_1 = {&LCU_data.coil_current_ems_1,max_persistent_current,max_time,frequency};
//	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_ems_3 = {&LCU_data.coil_current_ems_3,max_persistent_current,max_time,frequency};
//
//	uint8_t cur_hems_1_id = 0;
//	uint8_t cur_hems_3_id = 0;
//	uint8_t cur_ems_1_id = 0;
//	uint8_t cur_ems_3_id = 0;
//
//	uint8_t coil_temp_1_id = 0;
//	uint8_t coil_temp_2_id = 0;
//	uint8_t coil_temp_3_id = 0;
//	uint8_t coil_temp_4_id = 0;
//
//	uint8_t lpu_temp_1_id = 0;
//	uint8_t lpu_temp_2_id = 0;
//	uint8_t lpu_temp_3_id = 0;
//	uint8_t lpu_temp_4_id = 0;
//
//	uint8_t batt_cur_1_id = 0;
//	uint8_t batt_cur_2_id = 0;
//
//	uint8_t batt_volt_1_id = 0;
//	uint8_t batt_volt_2_id = 0;
//
//	uint8_t airgap_1_id = 0;
//	uint8_t airgap_3_id = 0;
//	uint8_t airgap_5_id = 0;
//	uint8_t airgap_7_id = 0;
//
//	void inscribe_adcs(){
//		cur_hems_1_id = ADC::inscribe(PB0).value();
//		cur_hems_3_id = ADC::inscribe(PB1).value();   //TODO: This is not correct
//		cur_ems_1_id = ADC::inscribe(PF11).value();
//		cur_ems_3_id = ADC::inscribe(PF12).value();
//
//		coil_temp_1_id = ADC::inscribe(PF5).value();
//		coil_temp_2_id = ADC::inscribe(PF6).value();
//		coil_temp_3_id = ADC::inscribe(PF7).value();
//		coil_temp_4_id = ADC::inscribe(PF8).value();
//
//		lpu_temp_1_id = ADC::inscribe(PC2).value();
//		lpu_temp_2_id = ADC::inscribe(PC3).value();
//		lpu_temp_3_id = ADC::inscribe(PF9).value();
//		lpu_temp_4_id = ADC::inscribe(PF10).value();
//
//		batt_cur_1_id = ADC::inscribe(PC0).value();
//		batt_cur_2_id = ADC::inscribe(PF13).value();
//
//		batt_volt_1_id = ADC::inscribe(PA0).value();
//		batt_volt_2_id = ADC::inscribe(PF14).value();
//
//		airgap_1_id = ADC::inscribe(PA5).value();
//		airgap_3_id = ADC::inscribe(PA6).value();
//		airgap_5_id = ADC::inscribe(PA4).value();
//		airgap_7_id = ADC::inscribe(PA3).value();
//
//	}
//
//	void turn_on_adcs(){
//		ADC::turn_on(cur_hems_1_id);
//		ADC::turn_on(cur_hems_3_id);
//		ADC::turn_on(cur_ems_1_id);
//		ADC::turn_on(cur_ems_3_id);
//
//		ADC::turn_on(coil_temp_1_id);
//		ADC::turn_on(coil_temp_2_id);
//		ADC::turn_on(coil_temp_3_id);
//		ADC::turn_on(coil_temp_4_id);
//
//		ADC::turn_on(lpu_temp_1_id);
//		ADC::turn_on(lpu_temp_2_id);
//		ADC::turn_on(lpu_temp_3_id);
//		ADC::turn_on(lpu_temp_4_id);
//
//		ADC::turn_on(batt_cur_1_id);
//		ADC::turn_on(batt_cur_2_id);
//
//		ADC::turn_on(batt_volt_1_id);
//		ADC::turn_on(batt_volt_2_id);
//
//		ADC::turn_on(airgap_1_id);
//		ADC::turn_on(airgap_3_id);
//		ADC::turn_on(airgap_5_id);
//		ADC::turn_on(airgap_7_id);
//	}
//
//	static void read_current();
//	static void read_airgap();
//
//
//};
//
//LCUSensors LCU_sensors;
//
//
//void LCUSensors::read_current(){
//		double raw_current = ((ADC::get_value(LCU_sensors.cur_hems_1_id) * -42.443) + 67.091);
//		LCU_data.coil_current_hems_1 = LCU_sensors.current_hems_1_mean.compute(raw_current);
//		LCU_sensors.time_protection_hems_1.check_accumulation(raw_current);
//
//		raw_current = ((ADC::get_value(LCU_sensors.cur_hems_3_id) * 42.443) - 54.701);
//		LCU_data.coil_current_hems_3 = LCU_sensors.current_hems_3_mean.compute(raw_current);
//		LCU_sensors.time_protection_hems_3.check_accumulation(raw_current);
//
//		raw_current = ((ADC::get_value(LCU_sensors.cur_ems_1_id) * -42.443) + 67.091);
//		LCU_data.coil_current_ems_1 = LCU_sensors.current_ems_1_mean.compute(raw_current);
//		LCU_sensors.time_protection_ems_1.check_accumulation(raw_current);
//
//		raw_current = ((ADC::get_value(LCU_sensors.cur_ems_3_id) * -42.443) + 67.091);
//		LCU_data.coil_current_ems_3 = LCU_sensors.current_ems_3_mean.compute(raw_current);
//		LCU_sensors.time_protection_ems_3.check_accumulation(raw_current);
//
//
//		float temp_1 = ADC::get_value(LCU_sensors.coil_temp_1_id);
//		float temp_2 = ADC::get_value(LCU_sensors.coil_temp_2_id);
//		float temp_3 = ADC::get_value(LCU_sensors.coil_temp_3_id);
//		float temp_4 = ADC::get_value(LCU_sensors.coil_temp_4_id);
//
//		LCU_data.coil_temp_1 = (841.836735/temp_1)  - 492.204082;
//		LCU_data.coil_temp_2 = (841.836735/temp_2)  - 492.204082;
//		LCU_data.coil_temp_3 = (841.836735/temp_3)  - 492.204082;
//		LCU_data.coil_temp_4 = (841.836735/temp_4)  - 492.204082;
//}
//
//void LCUSensors::read_airgap(){
//	double raw_airgap = ((ADC::get_value(LCU_sensors.airgap_1_id) * 17.23477) + 50.45231) - offset_mecanico;
//	LCU_data.airgap_1 = LCU_sensors.airgap_1_mean.compute(raw_airgap);
//
//	raw_airgap = ((ADC::get_value(LCU_sensors.airgap_3_id) * 17.23477) + 50.45231) - offset_mecanico;
//	LCU_data.airgap_3 = LCU_sensors.airgap_3_mean.compute(raw_airgap);
//
//	raw_airgap = ((ADC::get_value(LCU_sensors.airgap_5_id) * 17.23477) + 50.45231) - offset_mecanico;
//	LCU_data.airgap_5 = LCU_sensors.airgap_5_mean.compute(raw_airgap);
//
//	raw_airgap = ((ADC::get_value(LCU_sensors.airgap_7_id) * 17.23477) + 50.45231) - offset_mecanico;
//	LCU_data.airgap_7 = LCU_sensors.airgap_7_mean.compute(raw_airgap);
//}
//
//class LCUUDP{
//public:
//	DatagramSocket vcu_udp;
//
//	StackPacket<32,float,float,float,float,float,float,float,float> airgaps_data{
//		307,
//		&LCU_data.airgap_1,
//		&LCU_data.airgap_3,
//		&LCU_data.airgap_5,
//		&LCU_data.airgap_7,
//		&LCU_data.slave_airgap_2,
//		&LCU_data.slave_airgap_4,
//		&LCU_data.slave_airgap_6,
//		&LCU_data.slave_airgap_8
//	};
//
//	StackPacket<32,float,float,float,float,float,float,float,float> coil_currents{
//		313,
//		&LCU_data.coil_current_hems_1,
//		&LCU_data.coil_current_hems_3,
//		&LCU_data.coil_current_ems_1,
//		&LCU_data.coil_current_ems_3,
//		&LCU_data.slave_coil_current_hems_2,
//		&LCU_data.slave_coil_current_hems_4,
//		&LCU_data.slave_coil_current_ems_2,
//		&LCU_data.slave_coil_current_ems_4
//	};
//
//	StackPacket<32,float,float,float,float,float,float,float,float> coil_temperatures{
//		310,
//		&LCU_data.coil_temp_1,
//		&LCU_data.coil_temp_2,
//		&LCU_data.coil_temp_3,
//		&LCU_data.coil_temp_4,
//		&LCU_data.slave_coil_temp_1,
//		&LCU_data.slave_coil_temp_2,
//		&LCU_data.slave_coil_temp_3,
//		&LCU_data.slave_coil_temp_4
//	};
//
//	StackPacket<32,float,float,float,float,float,float,float,float> lpu_temperatures{
//		314,
//		&LCU_data.lpu_temp_1,
//		&LCU_data.lpu_temp_2,
//		&LCU_data.lpu_temp_3,
//		&LCU_data.lpu_temp_4,
//		&LCU_data.slave_lpu_temp_1,
//		&LCU_data.slave_lpu_temp_2,
//		&LCU_data.slave_lpu_temp_3,
//		&LCU_data.slave_lpu_temp_4
//	};
//
//	StackPacket<32,float,float,float,float,float,float,float,float> battery_data{
//		312,
//		&LCU_data.batt_voltage_1,
//		&LCU_data.batt_voltage_2,
//		&LCU_data.slave_batt_voltage_1,
//		&LCU_data.slave_batt_voltage_2,
//		&LCU_data.batt_current_1,
//		&LCU_data.batt_current_2,
//		&LCU_data.slave_batt_current_1,
//		&LCU_data.slave_batt_current_2
//	};
//
//	StackPacket<16,float,float,float,float> reference_distance_packet{
//		333,
//		&reference_distance,
//		&target_current,
//		&target_duty,
//		&LCU_sensors.time_protection_hems_3.accumulator
//	};
//
//
//public:
//	void register_connections(){
//		vcu_udp = DatagramSocket( IPV4("192.168.1.4"), 50400, IPV4("192.168.0.9"), 50400);
//		vcu_udp.local_ip = "192.168.1.4";
//		vcu_udp.local_port = 50400;
//		vcu_udp.remote_ip = "192.168.0.9";
//		vcu_udp.remote_port = 50400;
//		vcu_udp.udp_control_block->local_ip = vcu_udp.local_ip.address;
//		vcu_udp.udp_control_block->remote_ip = vcu_udp.remote_ip.address;
//		vcu_udp.udp_control_block->remote_port = 50400;
//		vcu_udp.udp_control_block->local_port = 50400;
//	}
//
//	static void send_all_data();
//};
//
//
//
//LCUUDP LCU_udp;
//
//void LCUUDP::send_all_data(){
//	LCU_udp.vcu_udp.send(LCU_udp.airgaps_data);
//	LCU_udp.vcu_udp.send(LCU_udp.coil_currents);
//	LCU_udp.vcu_udp.send(LCU_udp.reference_distance_packet);
//	LCU_udp.vcu_udp.send(LCU_udp.coil_temperatures);
//}
//
//class LCUMaster{
//public:
//	static LCUMaster LCU_MASTER;
//
//	LCUMasterData& lcu_data = LCU_data;
//	LCUSensors& lcu_sensors = LCU_sensors;
//	LCUActuators& lcu_actuators = LCU_actuators;
//	LCUUDP& lcu_backend_udp = LCU_udp;
//	LCUMaster() = default;
//
//	enum General_SM_States : uint8_t {
//		INITIAL,
//		OPERATIONAL,
//		FAULT
//	};
//
//	StateMachine general_sm = StateMachine(General_SM_States::OPERATIONAL);
//
//	uint8_t& general_state = general_sm.current_state;
//
//	uint8_t slave_general_state;
//
//	uint8_t specific_state = 0;
//
//	uint8_t slave_specific_state = 0;
//
//	int lcu_current_control_cyclic_id = -1;
//
//	CurrentControl current_control = {&lcu_actuators.HEMS_2_H1,&lcu_actuators.HEMS_2_H2};
//
//	DistanceControl distance_control;
//
//	bool control_state;
//
//	int control_counter = 0;
//
//public:
//
//	static void toggle_led(){
//		LCU_MASTER.lcu_actuators.toggle_led();
//	}
//
//	static void stop_control(){
//		LCUMaster::toggle_led();
//		LCU_MASTER.control_counter = 0;
//		LCU_MASTER.control_state = false;
//		LCU_MASTER.lcu_actuators.EMS_1_H1.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.EMS_1_H2.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.HEMS_1_H1.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.HEMS_1_H2.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.EMS_2_H1.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.EMS_2_H2.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.HEMS_2_H1.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.HEMS_2_H2.set_duty_cycle(0);
//		LCU_MASTER.lcu_actuators.EMS_1_H1.turn_off();
//		LCU_MASTER.lcu_actuators.EMS_1_H2.turn_off();
//		LCU_MASTER.lcu_actuators.HEMS_1_H1.turn_off();
//		LCU_MASTER.lcu_actuators.HEMS_1_H2.turn_off();
//		LCU_MASTER.lcu_actuators.EMS_2_H1.turn_off();
//		LCU_MASTER.lcu_actuators.EMS_2_H2.turn_off();
//		LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_off();
//		LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_off();
//		LCU_MASTER.lcu_actuators.buffer_enable.turn_on();
//		LCU_MASTER.lcu_actuators.fault_led.turn_on();
//		LCU_MASTER.current_control.current_pi.reset();
//		LCU_MASTER.distance_control.pid.reset();
//		if(LCU_MASTER.lcu_current_control_cyclic_id != -1) Time::unregister_mid_precision_alarm(LCU_MASTER.lcu_current_control_cyclic_id);
//		LCU_MASTER.general_sm.force_change_state(General_SM_States::FAULT);
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void execute_control(){
//		if(not (LCU_MASTER.general_sm.current_state == General_SM_States::OPERATIONAL)) return;
//		LCU_MASTER.distance_control.control(LCU_MASTER.lcu_data.airgap_3);
//		LCU_MASTER.current_control.set_reference_current(LCU_MASTER.distance_control.target_current);
//	}
//
//
//	static void start_control(){
//		LCUMaster::toggle_led();
//		if(LCU_MASTER.control_state == true) return;
//		LCU_MASTER.control_state = true;
//		LCU_MASTER.lcu_actuators.fault_led.turn_off();
//		LCU_MASTER.current_control.current_pi.reset();
//		LCU_MASTER.distance_control.pid.reset();
//		LCU_MASTER.lcu_current_control_cyclic_id = Time::register_mid_precision_alarm(1000, execute_control).value();
//		Time::register_mid_precision_alarm(500, execute_current_control);
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void change_reference_distance(){
//		LCUMaster::toggle_led();
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void check_protections(){
////		if(LCU_MASTER.lcu_data.coil_temp_3 > 40.0 && LCU_MASTER.control_state) stop_control();
//		if((not LCU_MASTER.lcu_sensors.time_protection_hems_1.still_good) && LCU_MASTER.control_state) stop_control();
//		if((not LCU_MASTER.lcu_sensors.time_protection_hems_3.still_good) && LCU_MASTER.control_state) stop_control();
//		if((not LCU_MASTER.lcu_sensors.time_protection_ems_1.still_good) && LCU_MASTER.control_state) stop_control();
//		if((not LCU_MASTER.lcu_sensors.time_protection_ems_3.still_good) && LCU_MASTER.control_state) stop_control();
//	}
//
//
//
//	void register_cyclic_actions(){
//		Time::register_mid_precision_alarm(500, LCUUDP::send_all_data);
//		Time::register_high_precision_alarm(100, LCUSensors::read_current);
//		Time::register_high_precision_alarm(133, LCUSensors::read_airgap);
//		Time::register_low_precision_alarm(1, Ethernet::update);
//		Time::register_low_precision_alarm(1, ErrorHandlerModel::ErrorHandlerUpdate);
//		Time::register_low_precision_alarm(1, check_protections);
//	}
//
//	static void execute_current_control(){
//		if(not (LCU_MASTER.general_sm.current_state == General_SM_States::OPERATIONAL)) return;
//		LCU_MASTER.current_control.control(LCU_MASTER.lcu_data.coil_current_hems_3);
//	}
//
//	static void test_current_loop(){
//		LCUMaster::toggle_led();
//		if(LCU_MASTER.control_state == true) return;
//		LCU_MASTER.current_control.current_pi.reset();
//		LCU_MASTER.control_state = true;
//		Time::register_mid_precision_alarm(500, execute_current_control);
//		LCU_MASTER.current_control.set_reference_current(current_reference_test);
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void test_open_loop(){
//		LCUMaster::toggle_led();
//		LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_on();
//		LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_on();
//		test_duty = test_duty > 100 - LCU_MASTER.current_control.half_bridge.offset ? 100 - LCU_MASTER.current_control.half_bridge.offset : test_duty;
//		LCU_MASTER.current_control.half_bridge.set_duty_cycle(test_duty);
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void change_open_loop_duty(){
//		LCUMaster::toggle_led();
//		LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_on();
//		LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_on();
//		test_duty = test_duty > 100 - LCU_MASTER.current_control.half_bridge.offset ? 100 - LCU_MASTER.current_control.half_bridge.offset : test_duty;
//		LCU_MASTER.current_control.half_bridge.set_duty_cycle(test_duty);
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void change_current_reference(){
//		LCUMaster::toggle_led();
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//
//	static void time_limit_fault(){
//		LCU_MASTER.lcu_sensors.time_protection_hems_3.still_good = false;
//	}
//
//	static void test_lpu(){
//		LCUMaster::toggle_led();
//		if(lpu_selector == LPU_1){
//			if(lpu_bridge == HEMS){
//				LCU_MASTER.lcu_actuators.HEMS_1_H1.turn_on();
//				LCU_MASTER.lcu_actuators.HEMS_1_H2.turn_on();
//				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
//				if(bridge_test_duty > 0){
//					LCU_actuators.HEMS_1_H2.set_duty_cycle(0);
//					LCU_actuators.HEMS_1_H1.set_duty_cycle(bridge_test_duty);
//				}else{
//					LCU_actuators.HEMS_1_H1.set_duty_cycle(0);
//					LCU_actuators.HEMS_1_H2.set_duty_cycle(bridge_test_duty);
//				}
//			}else{
//				LCU_MASTER.lcu_actuators.EMS_1_H1.turn_on();
//				LCU_MASTER.lcu_actuators.EMS_1_H2.turn_on();
//				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
//				if(bridge_test_duty > 0){
//					LCU_actuators.EMS_1_H2.set_duty_cycle(0);
//					LCU_actuators.EMS_1_H1.set_duty_cycle(bridge_test_duty);
//				}else{
//					LCU_actuators.EMS_1_H1.set_duty_cycle(0);
//					LCU_actuators.EMS_1_H2.set_duty_cycle(bridge_test_duty);
//				}
//			}
//		}else{
//			if(lpu_bridge == HEMS){
//				LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_on();
//				LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_on();
//				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
//				if(bridge_test_duty > 0){
//					LCU_actuators.HEMS_2_H2.set_duty_cycle(0);
//					LCU_actuators.HEMS_2_H1.set_duty_cycle(bridge_test_duty);
//				}else{
//					LCU_actuators.HEMS_2_H1.set_duty_cycle(0);
//					LCU_actuators.HEMS_2_H2.set_duty_cycle(bridge_test_duty);
//				}
//			}else{
//				LCU_MASTER.lcu_actuators.EMS_2_H1.turn_on();
//				LCU_MASTER.lcu_actuators.EMS_2_H2.turn_on();
//				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
//				if(bridge_test_duty > 0){
//					LCU_actuators.EMS_2_H2.set_duty_cycle(0);
//					LCU_actuators.EMS_2_H1.set_duty_cycle(bridge_test_duty);
//				}else{
//					LCU_actuators.EMS_2_H1.set_duty_cycle(0);
//					LCU_actuators.EMS_2_H2.set_duty_cycle(bridge_test_duty);
//				}
//			}
//		}
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	static void test_every_pwm(){
//		LCUMaster::toggle_led();
//		LCU_MASTER.lcu_actuators.HEMS_1_H1.turn_on();
//		LCU_MASTER.lcu_actuators.HEMS_1_H2.turn_on();
//		LCU_MASTER.lcu_actuators.EMS_1_H1.turn_on();
//		LCU_MASTER.lcu_actuators.EMS_1_H2.turn_on();
//		LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_on();
//		LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_on();
//		LCU_MASTER.lcu_actuators.EMS_2_H1.turn_on();
//		LCU_MASTER.lcu_actuators.EMS_2_H2.turn_on();
//		LCU_MASTER.lcu_actuators.HEMS_1_H1.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.HEMS_1_H2.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.EMS_1_H1.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.EMS_1_H2.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.HEMS_2_H1.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.HEMS_2_H2.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.EMS_2_H1.set_duty_cycle(50);
//		LCU_MASTER.lcu_actuators.EMS_2_H2.set_duty_cycle(50);
//		Time::set_timeout(500, LCUMaster::toggle_led);
//	}
//
//	void start(){//ServerSocket& server){
//		lcu_data.duty = &current_control.target_duty_cyle;
//		lcu_actuators.inscribe_digital_outputs();
//		lcu_sensors.inscribe_adcs();
//		STLIB::start("192.168.1.4", "255.255.0.0", "192.168.1.1");
//		general_sm.add_state(FAULT);
//		ProtectionManager::link_state_machine(general_sm, FAULT);
//		ProtectionManager::set_id(BoardID::LCU_MASTER);
//		lcu_sensors.turn_on_adcs();
//		lcu_backend_udp.register_connections();
//		register_cyclic_actions();
//		lcu_actuators.start();
//	}
//};

/*
 * LCU.hpp
 *
 *  Created on: Apr 6, 2023
 *      Author: stefa
 */

#pragma once

#include "main.h"
#include "lwip.h"
#include "ST-LIB.hpp"
#include "../Src/Runes/Runes.hpp"
#include "CurrentControl.hpp"

	void take_off();

	void landing();

	void stick_down();

	void stick_up();

	void set_parameters();

	void set_slave_parameters();

	extern float& reference_distance;
	extern float& target_current;
	extern float& target_duty;

	extern float current_reference_test;
	extern float test_duty;
	extern float bridge_test_duty;

enum LPU_Bridge{
	HEMS,EMS
};

enum LPU{
	LPU_1,
	LPU_2
};

extern LPU lpu_selector;
extern LPU_Bridge lpu_bridge;

struct LCUMasterData{
	float coil_current_hems_1 = 0;
	float coil_current_hems_3 = 0;
	float coil_current_ems_1 = 0;
	float coil_current_ems_3  = 0;

	float slave_coil_current_hems_2 = 0;
	float slave_coil_current_hems_4 = 0;
	float slave_coil_current_ems_2 = 0;
	float slave_coil_current_ems_4 = 0;

	float coil_temp_1 = 0;
	float coil_temp_2 = 0;
	float coil_temp_3 = 0;
	float coil_temp_4 = 0;

	float slave_coil_temp_1 = 0;
	float slave_coil_temp_2 = 0;
	float slave_coil_temp_3 = 0;
	float slave_coil_temp_4 = 0;

	float lpu_temp_1 = 0;
	float lpu_temp_2 = 0;
	float lpu_temp_3 = 0;
	float lpu_temp_4 = 0;

	float slave_lpu_temp_1 = 0;
	float slave_lpu_temp_2 = 0;
	float slave_lpu_temp_3 = 0;
	float slave_lpu_temp_4 = 0;

	float batt_current_1 = 0;
	float batt_current_2 = 0;

	float slave_batt_current_1 = 0;
	float slave_batt_current_2 = 0;

	float batt_voltage_1 = 0;
	float batt_voltage_2 = 0;

	float slave_batt_voltage_1 = 0;
	float slave_batt_voltage_2 = 0;

	float airgap_1 = 0;
	float airgap_3 = 0;
	float airgap_5 = 0;
	float airgap_7 = 0;

	float slave_airgap_2 = 0;
	float slave_airgap_4 = 0;
	float slave_airgap_6 = 0;
	float slave_airgap_8 = 0;

	double rotx = 0;
	double roty = 0;
	double rotz = 0;

	double reference_current_hems_1 = 0;
	double reference_current_hems_3 = 0;
	double reference_current_ems_1 = 0;
	double reference_current_ems_3 = 0;

	double slave_reference_current_hems_2 = 0;
	double slave_reference_current_hems_4 = 0;
	double slave_reference_current_ems_2 = 0;
	double slave_reference_current_ems_4 = 0;

	float raw_coil_current = 0;

	float* duty = nullptr;

};

LCUMasterData LCU_data;

class LCUActuators{
public:
	DigitalOutput buffer_enable;

	DigitalOutput sleep_led;
	DigitalOutput can_led;
	DigitalOutput flash_led;
	DigitalOutput fault_led;
	DigitalOutput operational_led;
	LPUHalfBridge HEMS_1{&HEMS_1_H1, &HEMS_1_H2}, HEMS_3{&HEMS_2_H1, &HEMS_2_H2}, EMS_1{&EMS_1_H1, &EMS_1_H2}, EMS_3{&EMS_2_H1, &EMS_2_H2};

	PWM HEMS_1_H1;
	PWM HEMS_1_H2;

	PWM HEMS_2_H1;
	PWM HEMS_2_H2;

	PWM EMS_1_H1;
	PWM EMS_1_H2;

	PWM EMS_2_H1;
	PWM EMS_2_H2;

	void inscribe_digital_outputs(){
		sleep_led = DigitalOutput(PG4);
		can_led = DigitalOutput(PG6);
		flash_led = DigitalOutput(PG5);
		fault_led = DigitalOutput(PG7);
		operational_led = DigitalOutput(PG8);

		buffer_enable = DigitalOutput(PD14);

		HEMS_1_H1 = PWM(PE9);
		HEMS_1_H2 = PWM(PE6);

		HEMS_2_H1 = PWM(PE11);
		HEMS_2_H2 = PWM(PE5);

		EMS_1_H1 = PWM(PE13);
		EMS_1_H2 = PWM(PE14);

		EMS_2_H1 = PWM(PB4);
		EMS_2_H2 = PWM(PB5);

	}

	void toggle_led(){
		flash_led.toggle();
	}

	void start(){
		buffer_enable.turn_off();
		flash_led.turn_off();
		can_led.turn_off();
		operational_led.turn_off();
		sleep_led.turn_off();
		fault_led.turn_off();
		HEMS_1_H1.turn_on();
		HEMS_1_H2.turn_on();
		EMS_1_H1.turn_on();
		EMS_1_H2.turn_on();
		HEMS_2_H1.turn_on();
		HEMS_2_H2.turn_on();
		EMS_2_H1.turn_on();
		EMS_2_H2.turn_on();
		HEMS_1_H1.set_frequency(20000);
		HEMS_1_H2.set_frequency(20000);
		EMS_1_H1.set_frequency(20000);
		EMS_1_H2.set_frequency(20000);
		HEMS_2_H1.set_frequency(20000);
		HEMS_2_H2.set_frequency(20000);
		EMS_2_H1.set_frequency(20000);
		EMS_2_H2.set_frequency(20000);
		HEMS_1_H1.set_duty_cycle(0);
		HEMS_1_H2.set_duty_cycle(0);
		EMS_1_H1.set_duty_cycle(0);
		EMS_1_H2.set_duty_cycle(0);
		HEMS_2_H1.set_duty_cycle(0);
		HEMS_2_H2.set_duty_cycle(0);
		EMS_2_H1.set_duty_cycle(0);
		EMS_2_H2.set_duty_cycle(0);
	}
};

LCUActuators LCU_actuators;

class LCUSensors{
public:

	static constexpr float  offset_mecanico = 63.303;
	static constexpr float max_persistent_current = 40;
	static constexpr float max_time = 1;
	static constexpr float frequency = 10000;

	MovingAverage<10> airgap_1_mean;
	MovingAverage<10> airgap_3_mean;
	MovingAverage<10> airgap_5_mean;
	MovingAverage<10> airgap_7_mean;
	MovingAverage<20> current_hems_1_mean;
	MovingAverage<20> current_hems_3_mean;
	MovingAverage<20> current_ems_1_mean;
	MovingAverage<20> current_ems_3_mean;

	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_hems_1 = {&LCU_data.coil_current_hems_1,max_persistent_current,max_time,frequency};
	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_hems_3 = {&LCU_data.coil_current_hems_3,max_persistent_current,max_time,frequency};
	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_ems_1 = {&LCU_data.coil_current_ems_1,max_persistent_current,max_time,frequency};
	Boundary<float,ProtectionType::TIME_ACCUMULATION> time_protection_ems_3 = {&LCU_data.coil_current_ems_3,max_persistent_current,max_time,frequency};

	uint8_t cur_hems_1_id = 0;
	uint8_t cur_hems_3_id = 0;
	uint8_t cur_ems_1_id = 0;
	uint8_t cur_ems_3_id = 0;

	uint8_t coil_temp_1_id = 0;
	uint8_t coil_temp_2_id = 0;
	uint8_t coil_temp_3_id = 0;
	uint8_t coil_temp_4_id = 0;

	uint8_t lpu_temp_1_id = 0;
	uint8_t lpu_temp_2_id = 0;
	uint8_t lpu_temp_3_id = 0;
	uint8_t lpu_temp_4_id = 0;

	uint8_t batt_cur_1_id = 0;
	uint8_t batt_cur_2_id = 0;

	uint8_t batt_volt_1_id = 0;
	uint8_t batt_volt_2_id = 0;

	uint8_t airgap_1_id = 0;
	uint8_t airgap_3_id = 0;
	uint8_t airgap_5_id = 0;
	uint8_t airgap_7_id = 0;

	void inscribe_adcs(){
		cur_hems_1_id = ADC::inscribe(PB0).value();
		cur_hems_3_id = ADC::inscribe(PB1).value();   //TODO: This is not correct
		cur_ems_1_id = ADC::inscribe(PF11).value();
		cur_ems_3_id = ADC::inscribe(PF12).value();

		coil_temp_1_id = ADC::inscribe(PF5).value();
		coil_temp_2_id = ADC::inscribe(PF6).value();
		coil_temp_3_id = ADC::inscribe(PF7).value();
		coil_temp_4_id = ADC::inscribe(PF8).value();

		lpu_temp_1_id = ADC::inscribe(PC2).value();
		lpu_temp_2_id = ADC::inscribe(PC3).value();
		lpu_temp_3_id = ADC::inscribe(PF9).value();
		lpu_temp_4_id = ADC::inscribe(PF10).value();

		batt_cur_1_id = ADC::inscribe(PC0).value();
		batt_cur_2_id = ADC::inscribe(PF13).value();

		batt_volt_1_id = ADC::inscribe(PA0).value();
		batt_volt_2_id = ADC::inscribe(PF14).value();

		airgap_1_id = ADC::inscribe(PA5).value();
		airgap_3_id = ADC::inscribe(PA6).value();
		airgap_5_id = ADC::inscribe(PA4).value();
		airgap_7_id = ADC::inscribe(PA3).value();

	}

	void turn_on_adcs(){
		ADC::turn_on(cur_hems_1_id);
		ADC::turn_on(cur_hems_3_id);
		ADC::turn_on(cur_ems_1_id);
		ADC::turn_on(cur_ems_3_id);

		ADC::turn_on(coil_temp_1_id);
		ADC::turn_on(coil_temp_2_id);
		ADC::turn_on(coil_temp_3_id);
		ADC::turn_on(coil_temp_4_id);

		ADC::turn_on(lpu_temp_1_id);
		ADC::turn_on(lpu_temp_2_id);
		ADC::turn_on(lpu_temp_3_id);
		ADC::turn_on(lpu_temp_4_id);

		ADC::turn_on(batt_cur_1_id);
		ADC::turn_on(batt_cur_2_id);

		ADC::turn_on(batt_volt_1_id);
		ADC::turn_on(batt_volt_2_id);

		ADC::turn_on(airgap_1_id);
		ADC::turn_on(airgap_3_id);
		ADC::turn_on(airgap_5_id);
		ADC::turn_on(airgap_7_id);
	}

	static void read_current();
	static void read_airgap();


};

LCUSensors LCU_sensors;


void LCUSensors::read_current(){
//		HAL_NVIC_DisableIRQ(TIM5_IRQn);
		double raw_current = ((ADC::get_value(LCU_sensors.cur_hems_1_id) * 44.746) - 85.72);
		LCU_data.coil_current_hems_1 = LCU_sensors.current_hems_1_mean.compute(raw_current);
		LCU_sensors.time_protection_hems_1.check_accumulation(raw_current);

		raw_current = ((ADC::get_value(LCU_sensors.cur_hems_3_id) * 44.746) - 85.72);
		LCU_data.coil_current_hems_3 = LCU_sensors.current_hems_3_mean.compute(raw_current);
		LCU_sensors.time_protection_hems_3.check_accumulation(raw_current);

		raw_current = ((ADC::get_value(LCU_sensors.cur_ems_1_id) * 44.746) - 85.72);
		LCU_data.coil_current_ems_1 = LCU_sensors.current_ems_1_mean.compute(raw_current);
		LCU_sensors.time_protection_ems_1.check_accumulation(raw_current);

		raw_current = ((ADC::get_value(LCU_sensors.cur_ems_3_id) * 44.746) - 85.72);
		LCU_data.coil_current_ems_3 = LCU_sensors.current_ems_3_mean.compute(raw_current);
		LCU_sensors.time_protection_ems_3.check_accumulation(raw_current);


		float temp_1 = ADC::get_value(LCU_sensors.coil_temp_1_id);
		float temp_2 = ADC::get_value(LCU_sensors.coil_temp_2_id);
		float temp_3 = ADC::get_value(LCU_sensors.coil_temp_3_id);
		float temp_4 = ADC::get_value(LCU_sensors.coil_temp_4_id);

		LCU_data.coil_temp_1 = (841.836735/temp_1)  - 492.204082;
		LCU_data.coil_temp_2 = (841.836735/temp_2)  - 492.204082;
		LCU_data.coil_temp_3 = (841.836735/temp_3)  - 492.204082;
		LCU_data.coil_temp_4 = (841.836735/temp_4)  - 492.204082;
//		HAL_NVIC_EnableIRQ(TIM5_IRQn);
}

void LCUSensors::read_airgap(){
	double raw_airgap = ((ADC::get_value(LCU_sensors.airgap_1_id) * 17.23477) + 50.45231) - offset_mecanico;
	LCU_data.airgap_1 = LCU_sensors.airgap_1_mean.compute(raw_airgap);

	raw_airgap = ((ADC::get_value(LCU_sensors.airgap_3_id) * 17.23477) + 50.45231) - offset_mecanico;
	LCU_data.airgap_3 = LCU_sensors.airgap_3_mean.compute(raw_airgap);

	raw_airgap = ((ADC::get_value(LCU_sensors.airgap_5_id) * 17.23477) + 50.45231) - offset_mecanico;
	LCU_data.airgap_5 = LCU_sensors.airgap_5_mean.compute(raw_airgap);

	raw_airgap = ((ADC::get_value(LCU_sensors.airgap_7_id) * 17.23477) + 50.45231) - offset_mecanico;
	LCU_data.airgap_7 = LCU_sensors.airgap_7_mean.compute(raw_airgap);
}

class LCUUDP{
public:
	DatagramSocket vcu_udp;

	StackPacket<32,float,float,float,float,float,float,float,float> airgaps_data{
		307,
		&LCU_data.airgap_1,
		&LCU_data.airgap_3,
		&LCU_data.airgap_5,
		&LCU_data.airgap_7,
		&LCU_data.slave_airgap_2,
		&LCU_data.slave_airgap_4,
		&LCU_data.slave_airgap_6,
		&LCU_data.slave_airgap_8
	};

	StackPacket<32,float,float,float,float,float,float,float,float> coil_currents{
		313,
		&LCU_data.coil_current_hems_1,
		&LCU_data.coil_current_hems_3,
		&LCU_data.coil_current_ems_1,
		&LCU_data.coil_current_ems_3,
		&LCU_data.slave_coil_current_hems_2,
		&LCU_data.slave_coil_current_hems_4,
		&LCU_data.slave_coil_current_ems_2,
		&LCU_data.slave_coil_current_ems_4
	};

	StackPacket<32,float,float,float,float,float,float,float,float> coil_temperatures{
		310,
		&LCU_data.coil_temp_1,
		&LCU_data.coil_temp_2,
		&LCU_data.coil_temp_3,
		&LCU_data.coil_temp_4,
		&LCU_data.slave_coil_temp_1,
		&LCU_data.slave_coil_temp_2,
		&LCU_data.slave_coil_temp_3,
		&LCU_data.slave_coil_temp_4
	};

	StackPacket<32,float,float,float,float,float,float,float,float> lpu_temperatures{
		314,
		&LCU_data.lpu_temp_1,
		&LCU_data.lpu_temp_2,
		&LCU_data.lpu_temp_3,
		&LCU_data.lpu_temp_4,
		&LCU_data.slave_lpu_temp_1,
		&LCU_data.slave_lpu_temp_2,
		&LCU_data.slave_lpu_temp_3,
		&LCU_data.slave_lpu_temp_4
	};

	StackPacket<32,float,float,float,float,float,float,float,float> battery_data{
		312,
		&LCU_data.batt_voltage_1,
		&LCU_data.batt_voltage_2,
		&LCU_data.slave_batt_voltage_1,
		&LCU_data.slave_batt_voltage_2,
		&LCU_data.batt_current_1,
		&LCU_data.batt_current_2,
		&LCU_data.slave_batt_current_1,
		&LCU_data.slave_batt_current_2
	};

	StackPacket<16,float,float,float,float> reference_distance_packet{
		333,
		&reference_distance,
		&target_current,
		&target_duty,
		&LCU_sensors.time_protection_ems_3.accumulator
	};


public:
	void register_connections(){
		vcu_udp = DatagramSocket( IPV4("192.168.1.4"), 50400, IPV4("192.168.0.9"), 50400);
		vcu_udp.local_ip = "192.168.1.4";
		vcu_udp.local_port = 50400;
		vcu_udp.remote_ip = "192.168.0.9";
		vcu_udp.remote_port = 50400;
		vcu_udp.udp_control_block->local_ip = vcu_udp.local_ip.address;
		vcu_udp.udp_control_block->remote_ip = vcu_udp.remote_ip.address;
		vcu_udp.udp_control_block->remote_port = 50400;
		vcu_udp.udp_control_block->local_port = 50400;
	}

	static void send_all_data();
};



LCUUDP LCU_udp;

void LCUUDP::send_all_data(){
	LCU_udp.vcu_udp.send(LCU_udp.airgaps_data);
	LCU_udp.vcu_udp.send(LCU_udp.coil_currents);
	LCU_udp.vcu_udp.send(LCU_udp.reference_distance_packet);
	LCU_udp.vcu_udp.send(LCU_udp.coil_temperatures);
}

class LCUMaster{
public:
	static LCUMaster LCU_MASTER;

	LCUMasterData& lcu_data = LCU_data;
	LCUSensors& lcu_sensors = LCU_sensors;
	LCUActuators& lcu_actuators = LCU_actuators;
	LCUUDP& lcu_backend_udp = LCU_udp;
	LCUMaster() = default;

	enum General_SM_States : uint8_t {
		INITIAL,
		OPERATIONAL,
		FAULT
	};

	StateMachine general_sm = StateMachine(General_SM_States::OPERATIONAL);

	uint8_t& general_state = general_sm.current_state;

	uint8_t slave_general_state;

	uint8_t specific_state = 0;

	uint8_t slave_specific_state = 0;

	int lcu_current_control_cyclic_id = -1;

	CurrentControl current_control = {&lcu_actuators.EMS_2_H1,&lcu_actuators.EMS_2_H2};

	DistanceControl distance_control;

	bool control_state;

	int control_counter = 0;

public:

	static void toggle_led(){
		LCU_MASTER.lcu_actuators.toggle_led();
	}

	static void stop_control(){
		LCUMaster::toggle_led();
		LCU_MASTER.control_counter = 0;
		LCU_MASTER.control_state = false;
		LCU_MASTER.lcu_actuators.EMS_1_H1.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.EMS_1_H2.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.HEMS_1_H1.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.HEMS_1_H2.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.EMS_2_H1.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.EMS_2_H2.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.HEMS_2_H1.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.HEMS_2_H2.set_duty_cycle(0);
		LCU_MASTER.lcu_actuators.EMS_1_H1.turn_off();
		LCU_MASTER.lcu_actuators.EMS_1_H2.turn_off();
		LCU_MASTER.lcu_actuators.HEMS_1_H1.turn_off();
		LCU_MASTER.lcu_actuators.HEMS_1_H2.turn_off();
		LCU_MASTER.lcu_actuators.EMS_2_H1.turn_off();
		LCU_MASTER.lcu_actuators.EMS_2_H2.turn_off();
		LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_off();
		LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_off();
		LCU_MASTER.lcu_actuators.buffer_enable.turn_on();
		LCU_MASTER.lcu_actuators.fault_led.turn_on();
		LCU_MASTER.current_control.current_pi.reset();
		LCU_MASTER.distance_control.pid.reset();
		if(LCU_MASTER.lcu_current_control_cyclic_id != -1) Time::unregister_mid_precision_alarm(LCU_MASTER.lcu_current_control_cyclic_id);
		LCU_MASTER.general_sm.force_change_state(General_SM_States::FAULT);
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void execute_control(){
		if(not (LCU_MASTER.general_sm.current_state == General_SM_States::OPERATIONAL)) return;
		LCU_MASTER.distance_control.control(LCU_MASTER.lcu_data.airgap_3);
		LCU_MASTER.current_control.set_reference_current(LCU_MASTER.distance_control.target_current);
	}


	static void start_control(){
		LCUMaster::toggle_led();
		if(LCU_MASTER.control_state == true) return;
		LCU_MASTER.control_state = true;
		LCU_MASTER.lcu_actuators.fault_led.turn_off();
		LCU_MASTER.current_control.current_pi.reset();
		LCU_MASTER.distance_control.pid.reset();
		LCU_MASTER.lcu_current_control_cyclic_id = Time::register_mid_precision_alarm(1000, execute_control).value();
		Time::register_mid_precision_alarm(500, execute_current_control);
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void change_reference_distance(){
		LCUMaster::toggle_led();
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void check_protections(){
//		if(LCU_MASTER.lcu_data.coil_temp_3 > 40.0 && LCU_MASTER.control_state) stop_control();
//		if((not LCU_MASTER.lcu_sensors.time_protection_hems_1.still_good) && LCU_MASTER.control_state) stop_control();
		if((not LCU_MASTER.lcu_sensors.time_protection_hems_3.still_good) && LCU_MASTER.control_state) stop_control();
//		if((not LCU_MASTER.lcu_sensors.time_protection_ems_1.still_good) && LCU_MASTER.control_state) stop_control();
		if((not LCU_MASTER.lcu_sensors.time_protection_ems_3.still_good) && LCU_MASTER.control_state) stop_control();
	}



	void register_cyclic_actions(){
		Time::register_mid_precision_alarm(500, LCUUDP::send_all_data);
		Time::register_high_precision_alarm(100, LCUSensors::read_current);
		Time::register_high_precision_alarm(133, LCUSensors::read_airgap);
		Time::register_low_precision_alarm(1, Ethernet::update);
		Time::register_low_precision_alarm(1, ErrorHandlerModel::ErrorHandlerUpdate);
		Time::register_low_precision_alarm(1, check_protections);
	}

	static void execute_current_control(){
		if(not (LCU_MASTER.general_sm.current_state == General_SM_States::OPERATIONAL)) return;
		LCU_MASTER.current_control.control(LCU_MASTER.lcu_data.coil_current_ems_3);
	}

	static void test_current_loop(){
		LCUMaster::toggle_led();
		if(LCU_MASTER.control_state == true) return;
		LCU_MASTER.current_control.current_pi.reset();
		LCU_MASTER.control_state = true;
		Time::register_mid_precision_alarm(500, execute_current_control);
		LCU_MASTER.current_control.set_reference_current(current_reference_test);
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void test_open_loop(){
		LCUMaster::toggle_led();
		LCU_MASTER.lcu_actuators.EMS_2_H1.turn_on();
		LCU_MASTER.lcu_actuators.EMS_2_H2.turn_on();
		test_duty = test_duty > 100 - LCU_MASTER.current_control.half_bridge.offset ? 100 - LCU_MASTER.current_control.half_bridge.offset : test_duty;
		LCU_MASTER.current_control.half_bridge.set_duty_cycle(test_duty);
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void change_open_loop_duty(){
		LCUMaster::toggle_led();
		LCU_MASTER.lcu_actuators.EMS_2_H1.turn_on();
		LCU_MASTER.lcu_actuators.EMS_2_H2.turn_on();
		test_duty = test_duty > 100 - LCU_MASTER.current_control.half_bridge.offset ? 100 - LCU_MASTER.current_control.half_bridge.offset : test_duty;
		LCU_MASTER.current_control.half_bridge.set_duty_cycle(test_duty);
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void change_current_reference(){
		LCUMaster::toggle_led();
		Time::set_timeout(500, LCUMaster::toggle_led);
	}


	static void time_limit_fault(){
		LCU_MASTER.lcu_sensors.time_protection_ems_3.still_good = false;
	}

	static void test_lpu(){
		LCUMaster::toggle_led();
		if(lpu_selector == LPU_1){
			if(lpu_bridge == HEMS){
				LCU_MASTER.lcu_actuators.HEMS_1_H1.turn_on();
				LCU_MASTER.lcu_actuators.HEMS_1_H2.turn_on();
				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
				LCU_MASTER.lcu_actuators.HEMS_1.set_duty_cycle(bridge_test_duty);
			}else{
				LCU_MASTER.lcu_actuators.EMS_1_H1.turn_on();
				LCU_MASTER.lcu_actuators.EMS_1_H2.turn_on();
				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
				LCU_MASTER.lcu_actuators.EMS_1.set_duty_cycle(bridge_test_duty);
			}
		}else{
			if(lpu_bridge == HEMS){
				LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_on();
				LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_on();
				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
				LCU_MASTER.lcu_actuators.HEMS_3.set_duty_cycle(bridge_test_duty);
			}else{
				LCU_MASTER.lcu_actuators.EMS_2_H1.turn_on();
				LCU_MASTER.lcu_actuators.EMS_2_H2.turn_on();
				bridge_test_duty = bridge_test_duty > 100? 100 : bridge_test_duty;
				LCU_MASTER.lcu_actuators.EMS_3.set_duty_cycle(bridge_test_duty);
			}
		}
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	static void test_every_pwm(){
		LCUMaster::toggle_led();
		LCU_MASTER.lcu_actuators.HEMS_1_H1.turn_on();
		LCU_MASTER.lcu_actuators.HEMS_1_H2.turn_on();
		LCU_MASTER.lcu_actuators.EMS_1_H1.turn_on();
		LCU_MASTER.lcu_actuators.EMS_1_H2.turn_on();
		LCU_MASTER.lcu_actuators.HEMS_2_H1.turn_on();
		LCU_MASTER.lcu_actuators.HEMS_2_H2.turn_on();
		LCU_MASTER.lcu_actuators.EMS_2_H1.turn_on();
		LCU_MASTER.lcu_actuators.EMS_2_H2.turn_on();
		LCU_MASTER.lcu_actuators.HEMS_1_H1.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.HEMS_1_H2.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.EMS_1_H1.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.EMS_1_H2.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.HEMS_2_H1.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.HEMS_2_H2.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.EMS_2_H1.set_duty_cycle(50);
		LCU_MASTER.lcu_actuators.EMS_2_H2.set_duty_cycle(50);
		Time::set_timeout(500, LCUMaster::toggle_led);
	}

	void start(){//ServerSocket& server){
		lcu_data.duty = &current_control.target_duty_cyle;
		lcu_actuators.inscribe_digital_outputs();
		lcu_sensors.inscribe_adcs();
		STLIB::start("192.168.1.4", "255.255.0.0", "192.168.1.1");
		general_sm.add_state(FAULT);
		ProtectionManager::link_state_machine(general_sm, FAULT);
		ProtectionManager::set_id(Boards::ID::LCU_MASTER);
		lcu_sensors.turn_on_adcs();
		lcu_backend_udp.register_connections();
		register_cyclic_actions();
		lcu_actuators.start();
	}
};




